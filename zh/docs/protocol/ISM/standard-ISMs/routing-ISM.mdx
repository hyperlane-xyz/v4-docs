---
title: "路由 ISM"
---

开发者可以使用 `RoutingISM` 将消息验证委托给不同的 ISM。这允许开发者根据消息内容或应用程序上下文更改安全模型。

此 ISM 根据消息的源链简单地切换安全模型。一个简单的用例是为每条链使用不同的[多重签名 ISM](./multisig-ISM) Validator 集。

最终，您可以想象一个 `DomainRoutingIsm` 根据源链上使用的共识协议类型路由到不同的基于轻客户端的 ISM。

## 接口

`RoutingISMs` 必须实现 `IRoutingIsm` 接口。

```solidity
// SPDX-License-Identifier: MIT OR Apache-2.0
pragma solidity >=0.8.0;

import {IInterchainSecurityModule} from "../IInterchainSecurityModule.sol";

interface IRoutingIsm is IInterchainSecurityModule {
    /**
     * @notice Returns the ISM responsible for verifying _message
     * @dev Can change based on the content of _message
     * @param _message Hyperlane formatted interchain message
     * @return module The ISM to use to verify _message
     */
    function route(
        bytes calldata _message
    ) external view returns (IInterchainSecurityModule module);
}
```

## 配置

hyperlane-monorepo 包含 `RoutingISM` 实现，`DomainRoutingIsm` 和 `DefaultFallbackRoutingIsm`，应用程序开发者可以开箱即用地部署，指定其所需的配置。

## 自定义

hyperlane-monorepo 包含应用程序开发者可以 fork 的抽象 `RoutingISM` 实现。

开发者只需实现 `route()` 函数。

通过创建自定义实现，应用程序开发者可以定制 `RoutingISM` 提供的安全性以满足其应用程序的需求。

例如，自定义实现可以根据消息的内容或接收消息的应用程序的状态来更改安全模型。
