---
title: "单元测试 - EVM"
---

对于 Foundry 的多链设置，单元测试可能具有挑战性。因此，我们提供了一个轻量级测试环境 [`MockHyperlaneEnvironment`](https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/main/solidity/contracts/mock/MockHyperlaneEnvironment.sol)，让您可以对跨链应用进行单元测试，而无需 fork 多个网络。

大多数多链应用都会构建在我们的 Mailbox 合约之上。因此，我们使用 `MockMailbox` 抽象了已部署 mailbox 的细节，我们的环境在同一条链上包含一个 `originMailbox` 和一个 `destinationMailbox`。在内部，我们将到达目标的消息存储在目标 mailbox 的 `inboundMessages` 映射中。我们通过将消息加入队列并使用 `MockMailbox.processNextInboundMessage()` 递增 `inboundProcessedNonce` 来模拟消息传递。

简单消息传递的 forge 测试设置如下：

## 发送消息

```solidity
contract SimpleMessagingTest is Test {
    // origin and destination domains (recommended to be the chainId)
    uint32 origin = 1;
    uint32 destination = 2;

    // both mailboxes will be on the same chain but different addresses
    MockMailbox originMailbox;
    MockMailbox destinationMailbox;

    // contract which can receive messages
    TestRecipient receiver;

    function setUp() public {
        originMailbox = new MockMailbox(origin);
        destinationMailbox = new MockMailbox(destination);
        originMailbox.addRemoteMailbox(destination, destinationMailbox);

        receiver = new TestRecipient();
    }

    function testSendMessage() public {
        string _message = "Aloha!";
        originMailbox.dispatch(
            destination,
            TypeCasts.addressToBytes32(address(receiver)),
            bytes(_message)
        );
        // simulating message delivery to the destinationMailbox
        destinationMailbox.processNextInboundMessage();
        assertEq(string(receiver.lastData()), _message);
    }
}
```

## 测试基于 Router 的应用

假设您正在测试继承自 `Router` 的 `TestCrosschainApp`：

```solidity
contract CrosschainAppTest is Test {
    // origin and destination domains (recommended to be the chainId)
    uint32 origin = 1;
    uint32 destination = 2;

    function setUp() public {
        environment = new MockHyperlaneEnvironment(origin, destination);

        // your cross-chain app
        TestCrosschainApp originTelephone  = new TestCrosschainApp(environment.mailboxes(origin));
        TestCrosschainApp destinationTelephone  = new TestCrosschainApp(environment.mailboxes(destination));

        // assuming you're inheriting the Router pattern from https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/main/solidity/contracts/client/Router.sol
        originTelephone.enrollRemoteRouter(destinationTelephone);
        destinationTelephone.enrollRemoteRouter(originTelephone);
    }
}
```

调用 `processNextPendingMessage()` 和 `processNextPendingMessageFromDestination()` 分别处理目标和源 mailbox 的入站消息。现在，您可以从源到目标以及反向进行跨链调用：

```solidity
    function testRemoteTelephoneCallFromOrigin() public {
        // check behavior on origin
        vm.expectEmit(true, true, true, false);
        emit TelephoneRinging(destination,  TypeCasts.bytes32ToAddress(destinationTelephone), "Hello!"); // example event on origin
        originTelephone.callRemote(destination,  TypeCasts.bytes32ToAddress(destinationTelephone), "Hello!");

        // simulating message delivery origin -> destination
        environment.processNextPendingMessage();

        // check behavior on destination
        assertEq(destinationTelephone.latestMessage(originTelephone) == "Hello!");
    }

    function testRemoteTelephoneCallFromDestination() public {
        // check behavior on destination
        vm.expectEmit(true, true, true, false);
        emit TelephoneRinging(origin,  TypeCasts.bytes32ToAddress(originTelephone), "Howdy!"); // example event on destination
        destinationTelephone.callRemote(origin,  TypeCasts.bytes32ToAddress(originTelephone), "Howdy!");

         // simulating message delivery destination -> origin
        environment.processNextPendingMessageFromDestination();

        // check behavior on origin
        assertEq(originTelephone.latestMessage(destinationTelephone) == "Howdy!");
    }
```

如果您想为您的应用使用自己的 ISM，可以通过将其传递给 Router 的 `initialize` 方法来覆盖 mailbox 提供的 `defaultIsm`，如下所示：

```solidity
contract CrosschainAppTest is Test {
    // origin and destination domains (recommended to be the chainId)
    uint32 origin = 1;
    uint32 destination = 2;

    function setUp() public {
        ...

        TestIgp igp = new TestIgp(); // example InterchainGasPaymaster passed as the hook

        // deploy your own ISM contracts to verify messages between originTelephone and destinationTelephone
        TelephoneISM originIsm = new TelephoneISM(); // local ISM for origin
        TelephoneISM destinationIsm = new TelephoneISM(); // local ISM for destination


        originTelephone.initialize(address(igp), address(originIsm), msg.sender);
        originTelephone.initialize(address(igp), address(destinationIsm), msg.sender);

        ...
    }
}
```

<Tip>
  您可以在此处找到我们的单元测试设置示例：
  [InterchainAccountRouterTest](https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/dae8b26ed65383844e4fbed7585deeb52da4e454/solidity/test/InterchainAccountRouter.t.sol#L38)。
</Tip>
